import asyncio
import logging
import PIL
from aiogram import F, Bot, Dispatcher, types
from aiogram.filters.command import Command
from config_reader import config
from src.ColQwen2Embeddings import ColQwen2Embeddings
from langchain_qdrant import QdrantVectorStore
from qdrant_client import models
from langchain.retrievers.ensemble import EnsembleRetriever
from aiogram.utils.formatting import (
    Bold, as_list, as_marked_section, HashTag
)
import base64
from io import BytesIO
from PIL import Image

# –í–∫–ª—é—á–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤–∞–∂–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
logging.basicConfig(level=logging.INFO)

logging.info("Loading embeddings")
embeddings = ColQwen2Embeddings()
logging.info("Embeddings loaded")

qdrant = QdrantVectorStore.from_existing_collection(
    embedding=embeddings,
    collection_name=config.QDRANT_COLLECTION_NAME.get_secret_value(),
    url=config.QDRANT_URL.get_secret_value(),
    api_key=config.QDRANT_API_KEY.get_secret_value()
)

retriever_text = qdrant.as_retriever(search_type="mmr", 
                                search_kwargs={"k": 7,
    "filter": models.Filter(
        should=[
            models.FieldCondition(
                key="metadata.type",
                match=models.MatchValue(
                    value="text"
                ),
            ),
        ]
    )
})

retriever_image = qdrant.as_retriever(search_type="mmr", 
                                search_kwargs={"k": 4,
    "filter": models.Filter(
        should=[
            models.FieldCondition(
                key="metadata.type",
                match=models.MatchValue(
                    value="image"
                ),
            ),
        ]
    )
})

ensemble_retriever = EnsembleRetriever(retrievers=[retriever_text, retriever_image],
                                      weights=[0.5, 0.5])

# –û–±—ä–µ–∫—Ç –±–æ—Ç–∞
bot = Bot(token=config.BOT_TOKEN.get_secret_value())
# –î–∏—Å–ø–µ—Ç—á–µ—Ä
dp = Dispatcher()

# –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å –∫–æ–º–∞–Ω–¥–∞–º–∏ –∏ –∏—Ö –æ–ø–∏—Å–∞–Ω–∏–µ–º
commands = [
    types.BotCommand(command="start", description="–ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º"),
    types.BotCommand(command="list_indexed", description="–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"),
    types.BotCommand(command="upload_pdf", description="–ó–∞–≥—Ä—É–∑–∏—Ç—å PDF –¥–æ–∫—É–º–µ–Ω—Ç"),
    types.BotCommand(command="del_indexed", description="–£–¥–∞–ª–∏—Ç—å –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç"),
]

# –•—ç–Ω–¥–ª–µ—Ä –Ω–∞ –∫–æ–º–∞–Ω–¥—É /start
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    await message.answer("–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å PDF –¥–æ–∫—É–º–µ–Ω—Ç–∞–º–∏.\n"
                        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                        "/upload_pdf - –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞\n"
                        "/list_indexed - –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–ø–∏—Å–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤\n"
                        "/del_indexed - –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞.\n\n"
                        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–æ–∏—Å–∫–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –æ—Ç –ò–ò —Å —É—á–µ—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞.")

# –•—ç–Ω–¥–ª–µ—Ä –Ω–∞ –∫–æ–º–∞–Ω–¥—É /list_indexed
@dp.message(Command("list_indexed"))
async def cmd_list_indexed(message: types.Message):
    # –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
    await message.answer("–°–ø–∏—Å–æ–∫ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤:\n"
                        "1. Document1.pdf\n"
                        "2. Document2.pdf\n"
                        "(–≠—Ç–æ —Ç–µ—Å—Ç–æ–≤—ã–π —Å–ø–∏—Å–æ–∫)")

# –•—ç–Ω–¥–ª–µ—Ä –Ω–∞ –∫–æ–º–∞–Ω–¥—É /upload_pdf
@dp.message(Command("upload_pdf"))
async def cmd_upload_pdf(message: types.Message):
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ PDF —Ñ–∞–π–ª –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ (–≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ)")

# –•—ç–Ω–¥–ª–µ—Ä –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ PDF —Ñ–∞–π–ª–∞
@dp.message(F.document)
async def handle_pdf_document(message: types.Message):
    if message.document.mime_type == "application/pdf":
        await message.answer(f"–ü–æ–ª—É—á–µ–Ω PDF —Ñ–∞–π–ª: {message.document.file_name}\n"
                           f"(–ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞)")
    else:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª –≤ —Ñ–æ—Ä–º–∞—Ç–µ PDF")

# –•—ç–Ω–¥–ª–µ—Ä –Ω–∞ –∫–æ–º–∞–Ω–¥—É /del_indexed
@dp.message(Command("del_indexed"))
async def cmd_del_indexed(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è\n"
                        "(–ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è)")

# –ó–∞–º–µ–Ω—è–µ–º –æ–±—â–∏–π —Ö—ç–Ω–¥–ª–µ—Ä –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
@dp.message(F.text)
async def handle_text(message: types.Message):
    #results = ensemble_retriever.invoke(message.text)
    results_text = retriever_text.invoke(message.text)
    results_image = retriever_image.invoke(message.text)

    texts = [f"{result.metadata['source']}/{result.metadata['page']} —Å—Ç—Ä./{result.page_content}" for result in results_text if result.metadata['type'] == 'text']
    images = [result.metadata['image_base64'] for result in results_image if result.metadata['type'] == 'image']
    images_captions = [f"{result.metadata['source']}/{result.metadata['page']} —Å—Ç—Ä." for result in results_image if result.metadata['type'] == 'image']
    
    for index, image in enumerate(images):
        try:
            # –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª–æ —Å—Ç—Ä–æ–∫–∏ base64 –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            logging.debug(f"Base64 string preview: {image[:50]}...")
            
            # –û—á–∏—Å—Ç–∫–∞ —Å—Ç—Ä–æ–∫–∏ base64 –æ—Ç –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –ø—Ä–µ—Ñ–∏–∫—Å–∞ –¥–∞–Ω–Ω—ã—Ö
            if ',' in image:
                image = image.split(',')[1]
            
            # –î–æ–±–∞–≤–ª—è–µ–º padding –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
            padding = 4 - (len(image) % 4) if len(image) % 4 else 0
            image = image + ('=' * padding)
            
            # –î–µ–∫–æ–¥–∏—Ä—É–µ–º base64 –≤ –±–∏–Ω–∞—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            img_data = base64.b64decode(image)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ
            if len(img_data) == 0:
                logging.error("–ü–æ–ª—É—á–µ–Ω—ã –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                continue
            
            # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç BytesIO –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            bio = BytesIO(img_data)
            bio.seek(0)
            
            # –û—Ç–∫—Ä—ã–≤–∞–µ–º –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            img = Image.open(bio)
            img = img.convert('RGB')  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ RGB —Ñ–æ—Ä–º–∞—Ç
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            output_bio = BytesIO()
            img.save(output_bio, format='JPEG', quality=95)
            output_bio.seek(0)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —á–∞—Ç
            await message.answer_photo(
                types.BufferedInputFile(
                    output_bio.getvalue(),
                    filename="image.jpg"
                ),
                caption=images_captions[index]
            )
            
        except base64.binascii.Error as e:
            logging.error(f"–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è base64: {e}", exc_info=True)
            continue
        except PIL.UnidentifiedImageError as e:
            logging.error(f"–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}", exc_info=True)
            continue
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}", exc_info=True)
            continue

    for index, text in enumerate(texts):
        content = as_list(
            as_marked_section(
                Bold(f"Multi-modal RAG context [{index+1}]:"),
                text,
                marker="üîé ",
            ),
            sep="\n\n",
        )
        await message.answer(**content.as_kwargs())
    await message.answer("LLM answer (Qwen): ...")

# –ó–∞–ø—É—Å–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ–ª–ª–∏–Ω–≥–∞ –Ω–æ–≤—ã—Ö –∞–ø–¥–µ–π—Ç–æ–≤
async def main():
    # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞
    await bot.set_my_commands(commands)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())